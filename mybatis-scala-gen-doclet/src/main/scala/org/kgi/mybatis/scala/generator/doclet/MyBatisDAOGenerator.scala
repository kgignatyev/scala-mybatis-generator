package org.kgi.mybatis.scala.generator.doclet

import java.io.{FileWriter, PrintWriter, File}
import collection.mutable.ArrayBuffer
import scala.util.matching.Regex

/**
 * Created by 
 * User: kgignatyev
 */
class MyBatisDAOGenerator(gd: GenerationData) {

  val outputDirName = gd.destinationDir + "/" + gd.targetPackage.replace('.', '/')


  def makeDaoFileName(cn: String): String = {
    outputDirName + "/" + cn + "_DAO.scala"
  }

  def writeHeader(out: PrintWriter) {
    out.println("package " + gd.targetPackage)

    val uniqueTypes = collection.mutable.Set[String]()

    val exclusionRegexps = List[Regex]( """scala.Predef.*""".r, """scala\.[a-zA-Z0-9_$]+""".r)

    gd.properties.foreach(pMapping => {


      if (!uniqueTypes.contains(pMapping.propFullType)) {
        if (!exclusionRegexps.exists(r => r.findAllIn(pMapping.propFullType).size > 0)) {
          uniqueTypes += pMapping.propFullType
        }
      }
    })
    uniqueTypes.foreach(uniqueType => {
      out.println("import " + uniqueType)
    })

    out.println( """|
                   |import org.mybatis.scala.mapping._
                   |import %2$s.%1$s
                   |import org.mybatis.scala.mapping.Binding._
                   |
                   |/**
                   | * Please do not change. This class is autogenerated.
                   | */
                   |object %1$s_DAO {
                   | """.stripMargin.format(gd.entityClassName, gd.entityClassPackage))
  }


  def writeResultMap(out: PrintWriter) {
    out.println("val result_Map = new ResultMap[" + gd.entityClassName + "] {")
    out.println("  id(column = \"%1$s\", property = \"%2$s\")".format(gd.id.colName, gd.id.propName))
    gd.noIdProperties.foreach(p => {
      out.println("  result(column = \"%1$s\", property = \"%2$s\") ".format(p.colName, p.propName))
    })
    out.println("}")
    out.println("")
  }

  def writeSelectSQL(out: PrintWriter) {

    out.println( """
                   |
                   |val SELECT_SQL =
                   |    <xsql>
                   |      SELECT *
                   |      FROM %s
                   |    </xsql>
                   |    """.stripMargin.format(gd.tableName))
  }

  def getTypeName(r: String): String = {
    if ("int".equals(r)) "Int" else if ("long".equals(r)) "Long" else if ("double".equals(r)) "Double" else r
  }

  def makeOrderBy(): String = {
    if (gd.sortBy.isEmpty) {
      ""
    } else {
      gd.sortBy.map(t => t._1 + " " + t._2).mkString("ORDER BY ", ",", "")
    }
  }

  def generateIdFinder(out: PrintWriter, p: Prop2columnMapping) {
    val ord = makeOrderBy()
    out.println( """
                   |val get%1$sBy_%2$s = new SelectOneBy[%4$s, %1$s] {
                   |    resultMap = result_Map
                   |
                   |    def xsql =
                   |      <xsql>
                   |        {SELECT_SQL}
                   |        WHERE %3$s = {"%2$s" ?}
                   |        %5$s
                   |      </xsql>
                   |  }
                   |  """.stripMargin.format(gd.entityClassName, p.propName, p.colName, p.propType, ord))
  }

  def generateEqFinder(out: PrintWriter, p: Prop2columnMapping) {
    val ord = makeOrderBy()
    def generateEq(byPage:String){
    out.println( """
                   |val find%1$s%6$sBy_%2$s = new SelectList%6$sBy[%4$s, %1$s] {
                   |    resultMap = result_Map
                   |
                   |    def xsql =
                   |      <xsql>
                   |        {SELECT_SQL}
                   |        WHERE %3$s = {"%2$s" ?}
                   |        %5$s
                   |      </xsql>
                   |  }
                   |  """.stripMargin.format(gd.entityClassName, p.propName, p.colName, p.propType, ord, byPage))
    }

    generateEq("")
    generateEq("Page")
  }

  def generateLikeFinder(out: PrintWriter, p: Prop2columnMapping) {
    def generateLike(byPage:String){
    out.println( """
                   |val find%1$s%6$s_%2$s_like = new SelectList%6$sBy[%4$s, %1$s] {
                   |    resultMap = result_Map
                   |
                   |    def xsql =
                   |      <xsql>
                   |        {SELECT_SQL}
                   |        WHERE %3$s LIKE {"%2$s" ?}
                   |        %5$s
                   |      </xsql>
                   |  }
                   |  """.stripMargin.format(gd.entityClassName, p.propName, p.colName, getTypeName(p.propType), makeOrderBy(),byPage))
    }

    generateLike("")
    generateLike("Page")
  }

  def generateEqDelete(out: PrintWriter, p: Prop2columnMapping) {
    out.println( """
                   |val delete%1$sBy_%2$s = new Delete[%4$s] {
                   |
                   |
                   |    def xsql =
                   |      <xsql>
                   |        DELETE FROM %5$s
                   |        WHERE %3$s = {"%2$s" ?}
                   |
                   |      </xsql>
                   |  }
                   |  """.stripMargin.format(gd.entityClassName, p.propName, p.colName, p.propType, gd.tableName))
  }

  def writeDelete(out: PrintWriter) {
    out.println(
      """
        |
        | val delete%1$sById = new Delete[Long]{
        |    def xsql =
        |          <xsql>
        |            DELETE FROM %2$s
        |            WHERE id = {"id" ?}
        |          </xsql>
        |  }
        |
      """.stripMargin.format(gd.entityClassName, gd.tableName))
  }

  def writeInsert(out: PrintWriter) {

    if ("String".equals(gd.id.propType) || gd.manualId) {
      out.println( """
                     |val insert = new Insert[%4$s] {
                     |def xsql =
                     |      <xsql>
                     |        INSERT INTO %1$s( %2$s )
                     |        VALUES ( %3$s )
                     |      </xsql>
                     |
                     |}
                     | """.stripMargin.format(gd.tableName,
        gd.properties.map(f => f.colName).mkString(", "),
        gd.properties.map(f => "{ \"" + f.propName + "\" ?}").mkString(", "),
        gd.entityClassName
      ))
    } else {

      out.println( """
                     |val insert = new Insert[%4$s] {
                     |def xsql =
                     |      <xsql>
                     |        INSERT INTO %1$s( %2$s )
                     |        VALUES ( %3$s )
                     |      </xsql>
                     |
                     |    keyGenerator = new SqlGeneratedKey[Long] {
                     |      keyProperty = "%5$s"
                     |
                     |      def xsql = "SELECT LAST_INSERT_ID()"
                     |    }
                     |}
                     | """.stripMargin.format(gd.tableName,
        gd.noIdProperties.map(f => f.colName).mkString(", "),
        gd.noIdProperties.map(f => "{ \"" + f.propName + "\" ?}").mkString(", "),
        gd.entityClassName,
        gd.id.propName
      ))
    }
  }

  def writeUpdate(out: PrintWriter) {
    out.println( """
                   |
                   |val update = new Update[%1$s]{
                   |    def xsql = <xsql>
                   |      UPDATE %2$s SET
                   |      %3$s
                   |      WHERE %4$s = {"%5$s"?}
                   |    </xsql>
                   |  }
                 """.stripMargin.format(gd.entityClassName, gd.tableName,
      gd.noIdProperties.map(f => f.colName + " = { \"" + f.propName + "\" ?}").mkString(",\n"),
      gd.id.colName, gd.id.propName
    )
    )
  }

  /**
   *
   * @param out
   * @param fields
   * @param stringFields
   */
  def generateBind(out: PrintWriter, fields: Iterable[Prop2columnMapping], stringFields: Iterable[Prop2columnMapping]) {
    // todo:  this method should take list of methods generated and put them in sequence
    out.println("val bind = Seq(")
    out.println("insert,delete%1$sById,update,".format(gd.entityClassName))
    out.println("get%1$sBy_%2$s,".format(gd.entityClassName, gd.id.propName))
    val items: Iterable[String] = fields.map(f => {
      List(
        "find%1$sBy_%2$s".format(gd.entityClassName, f.propName),
        "find%1$sPageBy_%2$s".format(gd.entityClassName, f.propName)
      )
    }).flatMap(l=>l)



    val items2: Iterable[String] = stringFields.map(f => {
      List(
      "find%1$s_%2$s_like".format(gd.entityClassName, f.propName),
      "find%1$sPage_%2$s_like".format(gd.entityClassName, f.propName)
      )
    }).flatMap(l=>l)

    val itemsDelete: Iterable[String] = fields.map(f => {
      "delete%1$sBy_%2$s".format(gd.entityClassName, f.propName)
    })

    out.println(List(items, items2, itemsDelete).flatMap(f => f).mkString(", \n"))

    out.println(")")
  }

  def generateDAO() {
    val outputDir = new File(outputDirName)
    if (!outputDir.exists()) {
      println("creating directory::" + outputDirName)
      outputDir.mkdirs()
    }
    val daoFileName: String = makeDaoFileName(gd.entityClassName)
    println("writing DAO to file:" + daoFileName)
    val out = new PrintWriter(new FileWriter(daoFileName))
    writeDAOContent(out)
    out.flush
    out.close
  }


  def writeDAOContent(out: PrintWriter) {
    writeHeader(out)
    writeResultMap(out)
    writeSelectSQL(out)
    writeInsert(out)
    writeUpdate(out)
    writeDelete(out)
    generateIdFinder(out, gd.id)

    gd.properties.foreach(p => {
      generateEqFinder(out, p)
      generateEqDelete(out, p)
    })

    val stringProperties: ArrayBuffer[Prop2columnMapping] = gd.properties.filter(f => f.propType.endsWith("String"))
    stringProperties.foreach(f => {
      generateLikeFinder(out, f)
    })

    generateBind(out, gd.properties, stringProperties)

    out.println("}")
  }
}

